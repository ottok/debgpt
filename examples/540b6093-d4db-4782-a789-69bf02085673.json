[
  {
    "role": "user",
    "content": "The following is the section 4.6 of Debian Policy:\n```\n4.6. Error trapping in makefiles\n================================\n\nWhen \"make\" invokes a command in a makefile (including your package\u2019s\nupstream makefiles and \"debian/rules\"), it does so using \"sh\". This\nmeans that \"sh\"\u2019s usual bad error handling properties apply: if you\ninclude a miniature script as one of the commands in your makefile\nyou\u2019ll find that if you don\u2019t do anything about it then errors are not\ndetected and \"make\" will blithely continue after problems.\n\nEvery time you put more than one shell command (this includes using a\nloop) in a makefile command you must make sure that errors are\ntrapped. For simple compound commands, such as changing directory and\nthen running a program, using \"&&\" rather than semicolon as a command\nseparator is sufficient. For more complex commands including most\nloops and conditionals you should include a separate \"set -e\" command\nat the start of every makefile command that\u2019s actually one of these\nminiature shell scripts.\n\n\n```\n\nPlease polish the language enclosed by the \"```\" marks. While polishing this document, the language must be precise. Additionally, any vague or ambiguous language is not acceptable. Furthermore, do not change the original meaning of the text while polishing. Now go ahead."
  },
  {
    "role": "assistant",
    "content": "4.6. Error Handling in Makefiles\n===============================\n\nWhen \"make\" executes a command from a makefile (including your package's upstream makefiles and \"debian/rules\"), it utilizes the \"sh\" shell. Consequently, the standard poor error handling characteristics of \"sh\" apply: if you include a small script as a command in your makefile, you'll find that if you don't address it explicitly, errors won't be detected, and \"make\" will carry on unfazed after encountering problems.\n\nIt is essential to ensure error detection whenever you include more than one command (which includes using loops) in a makefile command. For simple compound commands, such as changing directories and then running a program, using \"&&\" instead of a semicolon as a command separator is sufficient. For more complex commands, including most loops and conditionals, you should add a separate \"set -e\" command at the beginning of every makefile command that represents such a mini-script.\n\nThe original Debian Policy document is not altered during this polishing process. Here's the polished version:\n\n4.6. Error Handling in Makefiles\n===============================\n\nWhen the \"make\" utility executes a command from a makefile (including the upstream makefiles and the \"debian/rules\" file), it does so under the \"sh\" shell's control. As a result, this shell\u2019s typical suboptimal error handling comes into play. If you put multiple shell commands (a loop is an example) in a makefile command, failure to handle errors appropriately will cause \"make\" to proceed without detection, leading to further process execution with potential issues.\n\nTo alleviate this problem, be sure to employ proper error handling mechanisms whenever you put more than one shell command in a makefile command. For simple compound commands, like changing directories and then executing a program, using \"&&\" instead of a semicolon as a command separator is a valid solution. However, for more intricate commands, including most loops and conditionals, it is advisable to include a separate \"set -e\" command at the start of every makefile command that constitutes such a mini-script. This command ensures that the entire command sequence ceases execution as soon as an error occurs, notifying \"make\" of the condition and enabling it to take appropriate action."
  }
]